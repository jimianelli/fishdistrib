<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fish Distribution - Global FAO Areas</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a1929 0%, #1a2332 100%);
            color: #ffffff;
            overflow-x: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            width: 100%;
        }

        .globe-section {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #globeCanvas {
            max-width: 100%;
            max-height: 100%;
            cursor: grab;
        }

        #globeCanvas:active {
            cursor: grabbing;
        }

        .info-section {
            width: 400px;
            background: rgba(30, 41, 59, 0.9);
            padding: 30px;
            overflow-y: auto;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 28px;
            margin-bottom: 10px;
            color: #60a5fa;
            border-bottom: 2px solid #60a5fa;
            padding-bottom: 10px;
        }

        .subtitle {
            font-size: 14px;
            color: #94a3b8;
            margin-bottom: 30px;
        }

        .area-card {
            background: rgba(51, 65, 85, 0.7);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #60a5fa;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .area-card:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(96, 165, 250, 0.3);
        }

        .area-card h2 {
            font-size: 20px;
            color: #60a5fa;
            margin-bottom: 10px;
        }

        .area-card h3 {
            font-size: 16px;
            color: #94a3b8;
            margin-bottom: 15px;
        }

        .attribute {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
        }

        .attribute:last-child {
            border-bottom: none;
        }

        .attribute-label {
            font-weight: 600;
            color: #cbd5e1;
        }

        .attribute-value {
            color: #94a3b8;
            text-align: right;
        }

        .legend {
            margin-top: 30px;
            padding: 20px;
            background: rgba(51, 65, 85, 0.5);
            border-radius: 8px;
        }

        .legend h3 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #60a5fa;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .legend-text {
            font-size: 14px;
            color: #cbd5e1;
        }

        .species-list {
            margin-top: 12px;
            padding-left: 20px;
            color: #cbd5e1;
            font-size: 13px;
        }

        .species-list li {
            margin-bottom: 4px;
            list-style: disc;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
            font-size: 14px;
        }

        @media (max-width: 968px) {
            .container {
                flex-direction: column;
            }

            .info-section {
                width: 100%;
                height: 50vh;
            }

            .globe-section {
                height: 50vh;
            }
        }
    </style>
</head>
<body>
    <div class="tooltip" id="tooltip"></div>
    <div class="container">
        <div class="globe-section">
            <canvas id="globeCanvas"></canvas>
        </div>
        <div class="info-section">
            <h1>Fish Distribution</h1>
            <p class="subtitle">Global FAO Fishing Areas</p>
            
            <div id="area-cards"></div>

            <div class="legend">
                <h3>Legend</h3>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #22c55e;"></div>
                    <span class="legend-text">Overfished &lt; 25%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #f59e0b;"></div>
                    <span class="legend-text">Overfished 25–45%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ef4444;"></div>
                    <span class="legend-text">Overfished &gt; 45%</span>
                </div>
            </div>
        </div>
    </div>

  <script src="./static/js/fao-region-summary.js"></script>
  <script src="./static/js/land-polygons.js"></script>
    <script>
        // FAO fishing areas data with pins
        const regionCoordinates = {
            "21": { lat: 46, lng: -50 },
            "27": { lat: 58, lng: 0 },
            "31": { lat: 20, lng: -70 },
            "34": { lat: 7, lng: -20 },
            "37": { lat: 34, lng: 18 },
            "41": { lat: -38, lng: -55 },
            "47": { lat: -25, lng: 10 },
            "51": { lat: -8, lng: 52 },
            "57": { lat: -12, lng: 95 },
            "61": { lat: 45, lng: 150 },
            "67": { lat: 43, lng: -145 },
            "71": { lat: 8, lng: 150 },
            "77": { lat: -2, lng: -110 },
            "81": { lat: -40, lng: 165 },
            "87": { lat: -18, lng: -85 }
        };

        const speciesHighlights = {
            "21": ['American sea scallop', 'American lobster', 'Atlantic cod', 'Atlantic herring', 'Snow crab'],
            "31": ['Gulf menhaden', 'Caribbean spiny lobster', 'Queen conch', 'Red snapper'],
            "34": ['European pilchard', 'Bonga shad', 'Atlantic horse mackerel', 'Atlantic chub mackerel'],
            "37": ['European anchovy', 'European hake', 'Sardine', 'Bluefin tuna'],
            "41": ['Argentine shortfin squid', 'Argentine hake', 'Patagonian toothfish'],
            "47": ['Cape hake', 'Pilchards', 'Horse mackerel'],
            "51": ['Yellowfin tuna', 'Skipjack tuna', 'Indian oil sardine', 'Deepwater shrimp'],
            "57": ['Indian oil sardine', 'Ribbonfish', 'Hilsa shad', 'Penaeid shrimps'],
            "61": ['Walleye pollock', 'Japanese anchovy', 'Chum salmon', 'Pacific saury'],
            "67": ['Pacific salmon', 'Pacific hake', 'Pacific cod', 'Dungeness crab'],
            "71": ['Skipjack tuna', 'Yellowfin tuna', 'Bigeye tuna', 'Scads'],
            "77": ['Anchoveta', 'Pacific sardine', 'Jumbo flying squid'],
            "81": ['New Zealand hoki', 'Orange roughy', 'Rock lobster'],
            "87": ['Anchoveta', 'Jack mackerel', 'Chilean hake']
        };

        function getRegionColor(unsPct) {
            if (unsPct == null) return '#60a5fa';
            if (unsPct <= 25) return '#22c55e';
            if (unsPct <= 45) return '#f59e0b';
            return '#ef4444';
        }

        function formatPercent(value) {
            return value != null ? `${value.toFixed(1)}%` : '—';
        }

        function formatLandings(landings) {
            if (!landings || landings.landings_mt == null) return '—';
            return `${landings.landings_mt.toFixed(2)} Mt`;
        }

        const faoAreas = Array.isArray(FAO_REGION_SUMMARY)
            ? FAO_REGION_SUMMARY.map(region => {
                const coords = regionCoordinates[region.area_code];
                if (!coords) {
                    return null;
                }

                const percentages = region.percentages || {};
                const landings = region.landings || null;
                const unsPct = percentages.unsustainable_pct ?? null;
                const sustainablePct = percentages.sustainable_pct ?? null;
                const mainSpecies = (Array.isArray(region.main_species) && region.main_species.length
                    ? region.main_species
                    : speciesHighlights[region.area_code]) || [];

                return {
                    code: region.area_code,
                    title: `FAO Area ${region.area_code}`,
                    displayName: `FAO Area ${region.area_code} • ${region.name}`,
                    label: region.name,
                    lat: coords.lat,
                    lng: coords.lng,
                    color: getRegionColor(unsPct),
                    unsPct,
                    sustainablePct,
                    maxPct: percentages.max_sustainably_fished_pct ?? null,
                    underPct: percentages.underfished_pct ?? null,
                    totalStocks: region.total_stocks ?? null,
                    landings,
                    mainSpecies,
                    description: sustainablePct != null && unsPct != null
                        ? `Sustainable stocks: ${sustainablePct.toFixed(1)}% • Overfished: ${unsPct.toFixed(1)}%`
                        : 'Assessment summary pending update.'
                };
            }).filter(Boolean)
            : [];

        function renderAreaCards() {
            const container = document.getElementById('area-cards');
            if (!container) {
                return;
            }

            if (!faoAreas.length) {
                container.innerHTML = `
                    <div class="area-card">
                        <h2>FAO Regions</h2>
                        <h3>Data unavailable</h3>
                        <p style="margin-top: 10px; color: #94a3b8;">
                            Unable to load FAO region summary. Verify the auto-generated dataset is present.
                        </p>
                    </div>
                `;
                return;
            }

            const sorted = [...faoAreas].sort((a, b) => (b.unsPct ?? 0) - (a.unsPct ?? 0));
            container.innerHTML = sorted.map(area => `
                <div class="area-card" style="border-left-color: ${area.color};">
                    <h2>${area.title}</h2>
                    <h3>${area.label}</h3>
                    <div class="attribute">
                        <span class="attribute-label">Sustainable</span>
                        <span class="attribute-value">${formatPercent(area.sustainablePct)}</span>
                    </div>
                    <div class="attribute">
                        <span class="attribute-label">Overfished</span>
                        <span class="attribute-value">${formatPercent(area.unsPct)}</span>
                    </div>
                    <div class="attribute">
                        <span class="attribute-label">Underfished</span>
                        <span class="attribute-value">${formatPercent(area.underPct)}</span>
                    </div>
                    <div class="attribute">
                        <span class="attribute-label">Max Sustainably Fished</span>
                        <span class="attribute-value">${formatPercent(area.maxPct)}</span>
                    </div>
                    <div class="attribute">
                        <span class="attribute-label">Stocks assessed</span>
                        <span class="attribute-value">${area.totalStocks ?? '—'}</span>
                    </div>
                    <div class="attribute">
                        <span class="attribute-label">2021 Landings</span>
                        <span class="attribute-value">${formatLandings(area.landings)}</span>
                    </div>
                    ${area.landings && area.landings.landings_sustainable_pct != null ? `
                        <div class="attribute">
                            <span class="attribute-label">Landings sustainable</span>
                            <span class="attribute-value">${formatPercent(area.landings.landings_sustainable_pct)}</span>
                        </div>
                    ` : ''}
                    ${area.mainSpecies && area.mainSpecies.length ? `
                        <div class="attribute">
                            <span class="attribute-label">Key species</span>
                            <span class="attribute-value">${area.mainSpecies.slice(0, 3).join(', ')}</span>
                        </div>
                        ${area.mainSpecies.length > 3 ? `
                            <ul class="species-list">
                                ${area.mainSpecies.map(species => `<li>${species}</li>`).join('')}
                            </ul>
                        ` : ''}
                    ` : ''}
                </div>
            `).join('');
        }

        if (typeof LAND_POLYGONS === 'undefined') {
            console.warn('LAND_POLYGONS is not defined. Ensure static/js/land-polygons.js is loaded.');
        }

        renderAreaCards();

        if (typeof LAND_POLYGONS === 'undefined') {
            console.warn('LAND_POLYGONS is not defined. Ensure static/js/land-polygons.js is loaded.');
        }

        const canvas = document.getElementById('globeCanvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');

        let rotation = 0;
        let isDragging = false;
        let lastX = 0;
        let autoRotate = true;
        let stars = [];
        let animationTick = 0;
        let rotateResumeTimer;

        // Set canvas size
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth, container.clientHeight) * 0.9;
            canvas.width = size;
            canvas.height = size;
            createStars();
            drawGlobe();
        }

        function createStars() {
            const starCount = Math.max(60, Math.floor(canvas.width * canvas.height / 6500));
            stars = Array.from({ length: starCount }, () => ({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: Math.random() * 1.2 + 0.3,
                alpha: Math.random() * 0.5 + 0.3,
                twinkleOffset: Math.random() * Math.PI * 2
            }));
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Convert lat/lng to 3D coordinates
        function latLngToXYZ(lat, lng, radius) {
            const phi = lat * Math.PI / 180;
            const theta = lng * Math.PI / 180;
            return {
                x: radius * Math.cos(phi) * Math.sin(theta),
                y: radius * Math.sin(phi),
                z: radius * Math.cos(phi) * Math.cos(theta)
            };
        }

        // Project 3D point to 2D canvas
        function project3DTo2D(x, y, z, cosR, sinR, centerX, centerY) {
            const rotX = x * cosR - z * sinR;
            const rotZ = x * sinR + z * cosR;
            return {
                x: centerX + rotX,
                y: centerY - y,
                rotX,
                rotY: y,
                rotZ,
                visible: rotZ >= 0
            };
        }

        function hexToRGBA(hex, alpha) {
            const value = parseInt(hex.replace('#', ''), 16);
            const r = (value >> 16) & 255;
            const g = (value >> 8) & 255;
            const b = value & 255;
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Draw the globe
        function drawGlobe() {
            const radius = canvas.width / 2.5;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const lightX = centerX + Math.cos(rotation) * radius * 0.4;
            const lightY = centerY - radius * 0.25;
            const cosR = Math.cos(rotation);
            const sinR = Math.sin(rotation);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Deep space background
            const backgroundGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            backgroundGradient.addColorStop(0, '#051024');
            backgroundGradient.addColorStop(1, '#020617');
            ctx.fillStyle = backgroundGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Stars with subtle twinkle
            stars.forEach((star) => {
                const twinkle = (Math.sin(animationTick * 0.02 + star.twinkleOffset) + 1) * 0.5;
                const alpha = star.alpha * (0.7 + 0.3 * twinkle);
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(148, 197, 255, ${alpha})`;
                ctx.fill();
            });

            // Draw ocean
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            const oceanGradient = ctx.createRadialGradient(lightX, lightY, radius * 0.2, centerX, centerY, radius);
            oceanGradient.addColorStop(0, '#2563eb');
            oceanGradient.addColorStop(0.45, '#1d4ed8');
            oceanGradient.addColorStop(1, '#0b1c3d');
            ctx.fillStyle = oceanGradient;
            ctx.fill();

            // Draw faint water shimmer
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.clip();
            ctx.globalAlpha = 0.12;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            for (let r = radius * 0.25; r < radius; r += radius * 0.18) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.restore();

            // Draw grid lines
            ctx.save();
            ctx.strokeStyle = 'rgba(148, 197, 255, 0.18)';
            ctx.lineWidth = 0.8;
            ctx.lineCap = 'round';
            const gridVisibilityThreshold = -radius * 0.1;

            // Latitude lines
            for (let lat = -80; lat <= 80; lat += 20) {
                ctx.beginPath();
                let firstPoint = true;
                for (let lng = -180; lng <= 180; lng += 5) {
                    const pos3D = latLngToXYZ(lat, lng, radius);
                    const pos2D = project3DTo2D(pos3D.x, pos3D.y, pos3D.z, cosR, sinR, centerX, centerY);
                    if (pos2D.rotZ >= gridVisibilityThreshold) {
                        if (firstPoint) {
                            ctx.moveTo(pos2D.x, pos2D.y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(pos2D.x, pos2D.y);
                        }
                    } else {
                        firstPoint = true;
                    }
                }
                ctx.stroke();
            }

            // Longitude lines
            for (let lng = -180; lng < 180; lng += 20) {
                ctx.beginPath();
                let firstPoint = true;
                for (let lat = -90; lat <= 90; lat += 5) {
                    const pos3D = latLngToXYZ(lat, lng, radius);
                    const pos2D = project3DTo2D(pos3D.x, pos3D.y, pos3D.z, cosR, sinR, centerX, centerY);
                    if (pos2D.rotZ >= gridVisibilityThreshold) {
                        if (firstPoint) {
                            ctx.moveTo(pos2D.x, pos2D.y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(pos2D.x, pos2D.y);
                        }
                    } else {
                        firstPoint = true;
                    }
                }
                ctx.stroke();
            }
            ctx.restore();

            // Land gradient influenced by light position
            const landGradient = ctx.createRadialGradient(
                lightX,
                lightY,
                radius * 0.2,
                centerX,
                centerY,
                radius * 1.2
            );
            landGradient.addColorStop(0, '#34d399');
            landGradient.addColorStop(0.5, '#22c55e');
            landGradient.addColorStop(1, '#14532d');

            const reliefGradient = ctx.createLinearGradient(
                lightX,
                lightY,
                centerX,
                centerY + radius * 0.8
            );
            reliefGradient.addColorStop(0, 'rgba(148, 197, 255, 0.18)');
            reliefGradient.addColorStop(0.45, 'rgba(255, 255, 255, 0.02)');
            reliefGradient.addColorStop(1, 'rgba(15, 23, 42, 0.3)');

            const landSegments = [];
            if (Array.isArray(LAND_POLYGONS)) {
                LAND_POLYGONS.forEach(polygon => {
                    if (!Array.isArray(polygon) || polygon.length < 4) {
                        return;
                    }

                    const projected = polygon.map(([lng, lat]) => {
                        const pos3D = latLngToXYZ(lat, lng, radius);
                        return project3DTo2D(pos3D.x, pos3D.y, pos3D.z, cosR, sinR, centerX, centerY);
                    });

                    let segment = [];
                    for (let i = 0; i < projected.length - 1; i++) {
                        const current = projected[i];
                        const next = projected[i + 1];

                        if (current.visible) {
                            segment.push(current);
                        }

                        if (current.visible !== next.visible) {
                            const denom = current.rotZ - next.rotZ;
                            if (Math.abs(denom) > 1e-6) {
                                const t = current.rotZ / denom;
                                const ix = current.rotX + (next.rotX - current.rotX) * t;
                                const iy = current.rotY + (next.rotY - current.rotY) * t;
                                const intersection = {
                                    x: centerX + ix,
                                    y: centerY - iy,
                                    rotX: ix,
                                    rotY: iy,
                                    rotZ: 0,
                                    visible: true
                                };
                                segment.push(intersection);
                                if (segment.length >= 3) {
                                    landSegments.push(segment.map(point => ({
                                        x: point.x,
                                        y: point.y
                                    })));
                                }
                                segment = next.visible ? [intersection] : [];
                            }
                        } else if (!next.visible && segment.length) {
                            if (segment.length >= 3) {
                                landSegments.push(segment.map(point => ({
                                    x: point.x,
                                    y: point.y
                                })));
                            }
                            segment = [];
                        }
                    }

                    if (segment.length >= 3) {
                        landSegments.push(segment.map(point => ({
                            x: point.x,
                            y: point.y
                        })));
                    }
                });
            }

            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.clip();

            landSegments.forEach(points => {
                if (points.length < 3) {
                    return;
                }

                const path = new Path2D();
                path.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    path.lineTo(points[i].x, points[i].y);
                }
                path.closePath();

                ctx.save();
                ctx.shadowColor = 'rgba(15, 23, 42, 0.45)';
                ctx.shadowBlur = 12;
                ctx.globalAlpha = 0.9;
                ctx.fillStyle = landGradient;
                ctx.fill(path);
                ctx.restore();

                ctx.save();
                ctx.lineWidth = 0.8;
                ctx.strokeStyle = 'rgba(21, 128, 61, 0.65)';
                ctx.stroke(path);
                ctx.restore();

                ctx.save();
                ctx.lineWidth = 0.6;
                ctx.strokeStyle = 'rgba(236, 253, 245, 0.18)';
                ctx.setLineDash([3, 4]);
                ctx.stroke(path);
                ctx.restore();

                ctx.save();
                ctx.clip(path);
                ctx.globalAlpha = 0.65;
                ctx.fillStyle = reliefGradient;
                ctx.fillRect(centerX - radius, centerY - radius, radius * 2, radius * 2);
                ctx.restore();
            });

            ctx.restore();

            // Atmosphere glow
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 1.03, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(96, 165, 250, 0.45)';
            ctx.lineWidth = 2;
            ctx.shadowColor = 'rgba(96, 165, 250, 0.8)';
            ctx.shadowBlur = radius * 0.22;
            ctx.stroke();
            ctx.restore();

            // Day/Night terminator
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.clip();
            const terminatorGradient = ctx.createLinearGradient(
                centerX - Math.cos(rotation) * radius,
                centerY - Math.sin(rotation) * radius,
                centerX + Math.cos(rotation) * radius,
                centerY + Math.sin(rotation) * radius
            );
            terminatorGradient.addColorStop(0, 'rgba(2, 6, 23, 0)');
            terminatorGradient.addColorStop(0.5, 'rgba(2, 6, 23, 0.25)');
            terminatorGradient.addColorStop(1, 'rgba(2, 6, 23, 0.55)');
            ctx.fillStyle = terminatorGradient;
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillRect(centerX - radius, centerY - radius, radius * 2, radius * 2);
            ctx.globalCompositeOperation = 'source-over';

            const highlightGradient = ctx.createRadialGradient(
                lightX,
                lightY,
                radius * 0.15,
                centerX,
                centerY,
                radius
            );
            highlightGradient.addColorStop(0, 'rgba(148, 197, 255, 0.35)');
            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = highlightGradient;
            ctx.globalAlpha = 0.85;
            ctx.fillRect(centerX - radius, centerY - radius, radius * 2, radius * 2);
            ctx.restore();

            // Draw pins for FAO areas
            faoAreas.forEach(area => {
                const pos3D = latLngToXYZ(area.lat, area.lng, radius);
                const pos2D = project3DTo2D(pos3D.x, pos3D.y, pos3D.z, cosR, sinR, centerX, centerY);

                if (pos2D.visible) {
                    ctx.save();
                    const pulse = (Math.sin(animationTick * 0.08) + 1) * 0.5;
                    const pulseRadius = 12 + pulse * 4;
                    ctx.beginPath();
                    ctx.arc(pos2D.x, pos2D.y, pulseRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = hexToRGBA(area.color, 0.25 * (1 - pulse) + 0.15);
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(pos2D.x, pos2D.y, 10, 0, Math.PI * 2);
                    ctx.fillStyle = area.color;
                    ctx.shadowColor = hexToRGBA(area.color, 0.6);
                    ctx.shadowBlur = 14;
                    ctx.fill();
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.85)';
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(pos2D.x, pos2D.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fill();
                    ctx.restore();

                    area.screenX = pos2D.x;
                    area.screenY = pos2D.y;
                    area.isVisible = true;
                } else {
                    area.isVisible = false;
                }
            });

            // Draw globe outline
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(96, 165, 250, 0.9)';
            ctx.lineWidth = 2.5;
            ctx.stroke();
        }

        // Mouse interaction
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            autoRotate = false;
            clearTimeout(rotateResumeTimer);
            lastX = e.clientX;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastX;
                rotation -= deltaX * 0.01;
                lastX = e.clientX;
            } else {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                let hovering = false;
                faoAreas.forEach(area => {
                    if (area.isVisible) {
                        const dist = Math.hypot(mouseX - area.screenX, mouseY - area.screenY);
                        if (dist < 12) {
                            const statusLine = area.sustainablePct != null
                                ? `Sustainable ${formatPercent(area.sustainablePct)} • Overfished ${formatPercent(area.unsPct)}`
                                : 'Status pending';
                            const landingsLine = area.landings && area.landings.landings_mt != null
                                ? `Landings 2021: ${formatLandings(area.landings)}`
                                : null;
                            tooltip.innerHTML = `<strong>${area.displayName}</strong><br>${statusLine}${
                                landingsLine ? `<br>${landingsLine}` : ''
                            }<br>Lat: ${area.lat.toFixed(1)}°, Lng: ${area.lng.toFixed(1)}°`;
                            tooltip.style.left = `${e.clientX + 10}px`;
                            tooltip.style.top = `${e.clientY - 10}px`;
                            tooltip.style.opacity = '1';
                            hovering = true;
                        }
                    }
                });

                if (!hovering) {
                    tooltip.style.opacity = '0';
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            clearTimeout(rotateResumeTimer);
            rotateResumeTimer = setTimeout(() => autoRotate = true, 2000);
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            clearTimeout(rotateResumeTimer);
            rotateResumeTimer = setTimeout(() => autoRotate = true, 2000);
            tooltip.style.opacity = '0';
        });

        // Animation loop
        function animate() {
            if (autoRotate && !isDragging) {
                rotation += 0.005;
            }
            animationTick += 1;
            drawGlobe();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
